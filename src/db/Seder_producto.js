import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import csv from 'csv-parser';
import crypto from 'crypto';
import db from './db.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const posiblesPaths = [
  path.join(__dirname, './utils/nombre_total_marca.csv'),
  path.join(__dirname, '../utils/nombre_total_marca.csv'),
  path.join(__dirname, './nombre_total_marca.csv'),
  path.join(__dirname, '../data/nombre_total_marca.csv'),
  './data/nombre_total_marca.csv',
  './utils/nombre_total_marca.csv',
  './nombre_total_marca.csv'
];

const encontrarCSV = () => {
  console.log('üîç Buscando archivo CSV...');
  console.log('üìÇ Directorio actual del seeder:', __dirname);
  
  for (const csvPath of posiblesPaths) {
    console.log(`‚è≥ Verificando: ${csvPath}`);
    if (fs.existsSync(csvPath)) {
      console.log(`‚úÖ ¬°Archivo encontrado en: ${csvPath}`);
      return csvPath;
    }
  }
  
  return null;
};

const csvPath = encontrarCSV();

const capitalizar = (str) => {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
};

// Funci√≥n S√öPER ROBUSTA para extraer IDs num√©ricos
const extraerIDSeguro = (resultado, nombreCampo = 'id') => {
  console.log(`üîç Procesando resultado de returning:`, JSON.stringify(resultado));
  
  let valor = resultado;
  
  // Si es un array, tomar el primer elemento
  if (Array.isArray(valor)) {
    valor = valor[0];
    console.log(`üìã Primer elemento del array:`, JSON.stringify(valor));
  }
  
  // Si es un objeto, extraer el valor del campo
  if (typeof valor === 'object' && valor !== null) {
    // Buscar por el nombre espec√≠fico del campo o cualquier campo que termine en 'Id'
    const keys = Object.keys(valor);
    const idKey = keys.find(k => k === nombreCampo || k.toLowerCase().includes('id'));
    
    if (idKey) {
      valor = valor[idKey];
      console.log(`üóùÔ∏è  Extrayendo campo '${idKey}':`, valor);
    } else {
      // Si no hay clave espec√≠fica, tomar el primer valor
      valor = Object.values(valor)[0];
      console.log(`üéØ Tomando primer valor:`, valor);
    }
  }
  
  // Si es string, intentar parsear como JSON
  if (typeof valor === 'string') {
    try {
      const parsed = JSON.parse(valor);
      console.log(`üìÑ String parseado como JSON:`, parsed);
      return extraerIDSeguro(parsed, nombreCampo); // Recursi√≥n
    } catch (e) {
      // Si no es JSON v√°lido, intentar convertir a n√∫mero
      const numero = parseInt(valor);
      if (!isNaN(numero)) {
        console.log(`üî¢ String convertido a n√∫mero:`, numero);
        return numero;
      }
    }
  }
  
  // Convertir a n√∫mero
  const numeroFinal = parseInt(valor);
  if (isNaN(numeroFinal)) {
    console.error(`‚ùå No se pudo convertir a n√∫mero:`, valor);
    throw new Error(`Valor inv√°lido para ID: ${JSON.stringify(resultado)} -> ${valor}`);
  }
  
  console.log(`‚úÖ ID final extra√≠do:`, numeroFinal);
  return numeroFinal;
};

// Funci√≥n alternativa: usar SELECT despu√©s de INSERT
const insertarYObtenerID = async (tabla, datos, campoId) => {
  try {
    console.log(`üìù Insertando en ${tabla}:`, JSON.stringify(datos));
    
    // Opci√≥n 1: Intentar con returning
    try {
      const resultado = await db(tabla).insert(datos).returning(campoId);
      console.log(`üì• Resultado returning de ${tabla}:`, JSON.stringify(resultado));
      return extraerIDSeguro(resultado, campoId);
    } catch (returningError) {
      console.warn(`‚ö†Ô∏è  Returning fall√≥ en ${tabla}, intentando con SELECT...`);
    }
    
    // Opci√≥n 2: INSERT sin returning y luego SELECT del √∫ltimo
    await db(tabla).insert(datos);
    
    // Buscar el √∫ltimo registro insertado
    const ultimoRegistro = await db(tabla)
      .select(campoId)
      .orderBy(campoId, 'desc')
      .limit(1);
    
    if (ultimoRegistro.length === 0) {
      throw new Error(`No se encontr√≥ el registro insertado en ${tabla}`);
    }
    
    const id = ultimoRegistro[0][campoId];
    console.log(`üîç ID obtenido via SELECT en ${tabla}:`, id);
    return parseInt(id);
    
  } catch (error) {
    console.error(`‚ùå Error insertando en ${tabla}:`, error.message);
    throw error;
  }
};

// Funci√≥n para generar SOLO el c√≥digo de barras
const generarCodigoBarras = (nombre, marca) => {
  const nombreLimpio = nombre.replace(/[^a-zA-Z0-9]/g, '').toUpperCase();
  const marcaLimpia = marca.replace(/[^a-zA-Z0-9]/g, '').toUpperCase();
  const baseString = `${nombreLimpio}_${marcaLimpia}`;
  const hash = crypto.createHash('md5').update(baseString).digest('hex');
  const codigo = hash.substring(0, 12).replace(/[a-f]/g, (match) => {
    return String.fromCharCode(match.charCodeAt(0) - 87 + 48);
  }).replace(/[^0-9]/g, '').padEnd(12, '0').substring(0, 12);
  return codigo;
};

// Funci√≥n mejorada para obtener o crear proveedor
const obtenerProveedorId = async (marca) => {
  try {
    console.log(`üîç Buscando proveedor para marca: "${marca}"`);
    
    // Buscar proveedor existente
    const proveedores = await db('proveedor')
      .select('proveedorId', 'empresa')
      .whereRaw('LOWER(empresa) = LOWER(?)', [marca])
      .limit(1);
    
    if (proveedores.length > 0) {
      const id = parseInt(proveedores[0].proveedorId);
      console.log(`‚úÖ Proveedor encontrado: ID ${id} - ${proveedores[0].empresa}`);
      return id;
    }
    
    // Crear nuevo proveedor
    console.log(`üè≠ Creando nuevo proveedor para marca: "${marca}"`);
    const nuevoProveedor = {
      nombre: `Proveedor ${marca}`,
      empresa: marca,
      fono: '123456789',
      coordenadas: '-23.6597071,-70.3903201',
      tipoProducto: 'Productos Varios',
      correo: `contacto@${marca.toLowerCase().replace(/\s+/g, '').replace(/[^a-z0-9]/g, '')}.com`
    };
    
    const proveedorId = await insertarYObtenerID('proveedor', nuevoProveedor, 'proveedorId');
    console.log(`‚úÖ Nuevo proveedor creado: ID ${proveedorId} - ${marca}`);
    return proveedorId;
    
  } catch (error) {
    console.error(`‚ùå Error con proveedor "${marca}":`, error.message);
    
    // Fallback: buscar cualquier proveedor
    try {
      const cualquierProveedor = await db('proveedor').select('proveedorId').limit(1);
      if (cualquierProveedor.length > 0) {
        const id = parseInt(cualquierProveedor[0].proveedorId);
        console.log(`‚ö†Ô∏è  Usando proveedor fallback: ID ${id}`);
        return id;
      }
    } catch (fallbackError) {
      console.error('‚ùå Error en fallback:', fallbackError.message);
    }
    
    throw new Error(`No se pudo obtener proveedor para marca: ${marca}`);
  }
};

const seedProductos = async () => {
  try {
    console.log('üå± Iniciando seeder de productos MEJORADO...');

    if (!csvPath) {
      console.log('\n‚ùå No se encontr√≥ el archivo nombre_total_marca.csv en ninguna ubicaci√≥n:');
      posiblesPaths.forEach(p => console.log(`   - ${p}`));
      throw new Error('Archivo CSV no encontrado');
    }

    console.log(`üìÅ Usando archivo: ${csvPath}`);

    const productosData = [];

    // Leer CSV
    await new Promise((resolve, reject) => {
      fs.createReadStream(csvPath)
        .pipe(csv())
        .on('data', (row) => {
          if (productosData.length < 3) {
            console.log('üìÑ Fila le√≠da:', row);
          }
          
          const nuevoProducto = {
            nombre: capitalizar(row.nombre || row.Nombre || ''),
            categoria: capitalizar(row.area || row.categoria || ''),
            marca: capitalizar(row.Marca || row.marca || 'Sin Marca'),
            imagenUrl: null,
            pais: capitalizar(row.pais || row.Pais || 'Chile'),
            caracteristicas: row.caracteristica || row.caracteristicas || '',
            precio: parseFloat(row.precio) || 0.0,
            stock: parseInt(row.stock) || 5,
            estado: true
          };

          productosData.push(nuevoProducto);
        })
        .on('end', () => {
          console.log(`üìä ${productosData.length} productos procesados del CSV`);
          resolve();
        })
        .on('error', reject);
    });

    if (productosData.length === 0) {
      console.log('‚ö†Ô∏è  No hay datos para insertar');
      return;
    }

    // Verificar tablas
    const tablas = ['producto', 'barCode', 'proveedor'];
    for (const tabla of tablas) {
      const existe = await db.schema.hasTable(tabla);
      if (!existe) {
        throw new Error(`Tabla "${tabla}" no existe. Ejecuta las migraciones primero.`);
      }
    }
    console.log('‚úÖ Todas las tablas encontradas');

    // Mostrar proveedores existentes
    console.log('\nüìã Proveedores existentes:');
    const proveedoresExistentes = await db('proveedor').select('proveedorId', 'empresa', 'nombre');
    if (proveedoresExistentes.length > 0) {
      proveedoresExistentes.forEach(p => {
        console.log(`   üè¢ ID: ${p.proveedorId} - ${p.empresa}`);
      });
    } else {
      console.log('   ‚ö†Ô∏è  No hay proveedores - se crear√°n nuevos');
    }

    // Limpiar solo productos y c√≥digos de barras
    console.log('\nüßπ Limpiando productos y c√≥digos de barras...');
    await db('producto').del();
    await db('barCode').del();
    console.log('‚úÖ Limpieza completada - Proveedores conservados');

    console.log('\nüì¶ Procesando productos...');
    
    const cacheProveedores = new Map();
    let productosInsertados = 0;
    let erroresCount = 0;
    
    // Procesar cada producto
    for (let i = 0; i < productosData.length; i++) {
      const producto = productosData[i];
      
      try {
        console.log(`\n--- Procesando producto ${i + 1}/${productosData.length}: "${producto.nombre}" ---`);
        
        // Obtener proveedor
        let proveedorId;
        if (cacheProveedores.has(producto.marca)) {
          proveedorId = cacheProveedores.get(producto.marca);
          console.log(`üìã Proveedor en cache: ${proveedorId}`);
        } else {
          proveedorId = await obtenerProveedorId(producto.marca);
          cacheProveedores.set(producto.marca, proveedorId);
        }

        // Generar c√≥digo de barras
        const codigoBarras = generarCodigoBarras(producto.nombre, producto.marca);
        const nombreCorto = producto.nombre.substring(0, 20);
        const urlOptimizada = `https://barcode.orcascan.com/?type=code128&data=${codigoBarras}&format=svg&width=300&height=80&layout=landscape&text=${encodeURIComponent(nombreCorto)}`;
        
        // Insertar c√≥digo de barras
        const barCodeData = {
          codigoGuardad: codigoBarras,
          formato: 'CODE128',
          url: urlOptimizada
        };
        
        const barCodeId = await insertarYObtenerID('barCode', barCodeData, 'barCodeId');

        // Validar que ambos IDs sean n√∫meros v√°lidos
        if (!Number.isInteger(proveedorId) || proveedorId <= 0) {
          throw new Error(`ProveedorId inv√°lido: ${proveedorId}`);
        }
        if (!Number.isInteger(barCodeId) || barCodeId <= 0) {
          throw new Error(`BarCodeId inv√°lido: ${barCodeId}`);
        }

        console.log(`üì¶ Insertando producto con proveedorId: ${proveedorId}, barCodeId: ${barCodeId}`);

        // Insertar producto - SIN usar returning para evitar problemas
        const productoData = {
          nombre: producto.nombre,
          categoria: producto.categoria,
          marca: producto.marca,
          imagenUrl: producto.imagenUrl,
          pais: producto.pais,
          caracteristicas: producto.caracteristicas,
          precio: producto.precio,
          stock: producto.stock,
          estado: producto.estado,
          proveedorId: proveedorId,  // N√∫mero directo
          barCodeId: barCodeId       // N√∫mero directo
        };

        await db('producto').insert(productoData);

        productosInsertados++;
        console.log(`‚úÖ Producto ${productosInsertados} insertado correctamente`);

        if (productosInsertados % 10 === 0) {
          console.log(`üéØ Progreso: ${productosInsertados}/${productosData.length} productos...`);
        }

      } catch (error) {
        erroresCount++;
        console.error(`‚ùå Error en producto ${i + 1} "${producto.nombre}":`, error.message);
        
        if (erroresCount > 5 && productosInsertados === 0) {
          console.error('üí• Demasiados errores consecutivos. Deteniendo.');
          throw new Error('Proceso detenido por m√∫ltiples errores');
        }
        
        continue;
      }
    }

    console.log(`\nüéâ Proceso completado:`);
    console.log(`   ‚úÖ Productos insertados: ${productosInsertados}`);
    console.log(`   ‚ùå Errores: ${erroresCount}`);
    
    if (productosInsertados === 0) {
      console.log('\n‚ö†Ô∏è  No se insert√≥ ning√∫n producto.');
      return;
    }
    
    // Verificar resultados
    console.log('\nüîç Verificando datos insertados...');
    const ejemplosVerificacion = await db('producto')
      .select('productoId', 'nombre', 'marca', 'proveedorId', 'barCodeId')
      .limit(5);
    
    console.log('\nüìã Verificaci√≥n de tipos de datos:');
    ejemplosVerificacion.forEach((prod, index) => {
      console.log(`   ${index + 1}. ${prod.nombre}`);
      console.log(`      proveedorId: ${prod.proveedorId} (tipo: ${typeof prod.proveedorId})`);
      console.log(`      barCodeId: ${prod.barCodeId} (tipo: ${typeof prod.barCodeId})`);
    });

    // Estad√≠sticas finales
    console.log('\nüìä Estad√≠sticas finales:');
    const stats = await Promise.all([
      db('producto').count('* as total'),
      db('barCode').count('* as total'),
      db('proveedor').count('* as total')
    ]);
    
    console.log(`   üõçÔ∏è  Productos: ${stats[0][0].total}`);
    console.log(`   üì¶ C√≥digos de barras: ${stats[1][0].total}`);
    console.log(`   üè¢ Proveedores: ${stats[2][0].total}`);

    // Verificar joins funcionan correctamente
    console.log('\nüîó Verificando relaciones (JOINs):');
    try {
      const relacionesTest = await db('producto')
        .join('barCode', 'producto.barCodeId', 'barCode.barCodeId')
        .join('proveedor', 'producto.proveedorId', 'proveedor.proveedorId')
        .select('producto.nombre', 'proveedor.empresa', 'barCode.codigoGuardad')
        .limit(3);
      
      if (relacionesTest.length > 0) {
        console.log('‚úÖ JOINs funcionan correctamente:');
        relacionesTest.forEach((rel, i) => {
          console.log(`   ${i + 1}. ${rel.nombre} ‚Üí ${rel.empresa} ‚Üí ${rel.codigoGuardad}`);
        });
      } else {
        console.log('‚ö†Ô∏è  No se pudieron ejecutar los JOINs correctamente');
      }
    } catch (joinError) {
      console.error('‚ùå Error en JOINs:', joinError.message);
    }

  } catch (error) {
    console.error('‚ùå Error en seeder:', error.message);
    throw error;
  } finally {
    await db.destroy();
    console.log('\nüîí Conexi√≥n cerrada');
  }
};

// Ejecutar seeder
const ejecutarSeeder = async () => {
  try {
    await seedProductos();
    console.log('üéâ Seeder completado exitosamente');
    process.exit(0);
  } catch (error) {
    console.error('üí• Error ejecutando seeder:', error.message);
    console.log('\nüí° Sugerencias:');
    console.log('   1. Verifica las migraciones');
    console.log('   2. Revisa el CSV');
    console.log('   3. Verifica la conexi√≥n a BD');
    console.log('   4. Revisa los logs detallados arriba');
    process.exit(1);
  }
};

// Funci√≥n para debug
const mostrarEstructura = () => {
  console.log('\nüìÅ Estructura de carpetas:');
  console.log('   üìÇ Directorio del seeder:', __dirname);
  
  try {
    const contenido = fs.readdirSync(__dirname);
    console.log('   üìÇ Contenido:');
    contenido.forEach(item => {
      const itemPath = path.join(__dirname, item);
      const esDirectorio = fs.statSync(itemPath).isDirectory();
      console.log(`      ${esDirectorio ? 'üìÅ' : 'üìÑ'} ${item}`);
    });
  } catch (error) {
    console.log('   ‚ùå No se pudo leer el directorio');
  }
  console.log('\n');
};

mostrarEstructura();
ejecutarSeeder();